---
layout: single

title: "[TIL] 2025-03-05"

categories:
    - TIL
tag: [TIL]

date: 2025-03-05
last_modified_at: 2025-03-05

order : 77
---

# 2025-03-05 TIL

## 알고리즘 문제

문제의 알고리즘 자체는 어렵진 않았지만, 어떤식으로 알고리즘을 구현해야할지 고민이 많이 됐습니다.  
새로운 알고리즘들이 학습되고, 다양한 자료구조를 응용하는 방법을 학습하면서 문제를 푸는 실력이 조금씩 늘고있다고 느껴집니다!  
[프로그래머스 프로세스]({{ "/programmers/프로그래머스-프로세스/" | relative_url }}){: target="_blank"}

## C++

이전에 알고리즘 함수에 대한 강의를 진행했었는데, 정리하지 못했던 부분을 오늘 정리하면서 복습해보았습니다.  
`max_element`, `min_element`, `minmax_element`와 `count`, `count_if`에 대한 부분을 추가로 정리했습니다.  
[[C++ STL] algorithm]({{ "/cpp/CPP_STL-Algorithm/" | relative_url }}){: target="_blank"}

### 입출력 성능 최적화

`ios::sync_with_stdio(false)`, `cin.tie(NULL)`, `cout.tie(NULL)` 이 함수들은 C와 C++의 표준 stream 동기화 연결 해제합니다.

`ios::sync_with_stdio(false)`함수는 C++의 입출력 스트림(`cin`, `cout`)과 C의 입출력 스트림(`stdin`, `stdout`)의 동기화를 해제합니다.  
이 결과로 `cin`과 `cout`의 속도가 크게 향상됩니다.  
하지만 혼용할 경우 예측할 수 없는 동작을 할 수 있습니다.

```cpp
#include <iostream>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);

    printf("Hello");
    cout << "World"; // 동기화가 끊겼으므로 순서가 보장되지 않음
}
```

C++에서 입출력 스트림을 묶어(tie) 놓는 개념이 있습니다.  
기본적으로 `cin`과 `cout`이 묶여있어서 `cin`을 호출하면 `cout`이 버퍼를 비웁니다.(flush)  
`cin.tie(NULL)`함수는 위의 묶어 놓는 개념을 해제하는 개념입니다.  
즉, `cin`을 호출해도 `cout`이 자동으로 버퍼를 비우지 않으므로 중요한 출력은 강제로 버퍼를 비우는것이 좋습니다.

```cpp
#include <iostream>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL); // cin과 cout의 연결을 끊음

    int a, b;
    cin >> a >> b;
    cout << a + b << '\n';
}
```

`cout.tie(NULL)`이 함수는 일반적으로 묶여 있는 다른 출력 스트림이 없기 때문에 실질적인 의미가 없으며, 대부분의 경우에 필요하지 않아 그냥 두어도 성능에 큰 영향을 주지 않습니다.  
만약 특정 스트림과 묶여있다면 `cin.tie(NULL)`과 비슷하게 해제하는 역할을 합니다.

결과적으로 위의 함수들은 실행 시간을 단축한다는 사실 만으로 최적화처럼 보이지만 모든 프로그램에서 입출력 시간을 절약하기 위해 사용하는 올바른 방법은 아닙니다.  
알고리즘 문제를 풀 때 시간을 절약하기 위해 사용하는 것이 좋은 것 같습니다.

## 알고리즘

버블 정렬에 대해 복습하면서 정리해보았습니다.  
가장 기본이 되는 정렬이라 기존에 알고있는 정렬이었지만, 좀 더 자세히 알아보려고 해보았고 복습하면서 되세겨볼 수 있는 시간이었습니다.  
[[Algorithm] 버블 정렬]({{ "/algorithm/Algorithm-Bubble_Sort/" | relative_url }}){: target="_blank"}

## 스파르타 내배캠

오늘은 팀 작업에서 규칙대로 되지 않는 부분이 있는데, 풀 리퀘스트의 승인을 규칙대로 하지 않아 충돌이 일어나거나 의사소통에 혼선이 생겨 어려운 점이 있었습니다.  
현재 조에서 합의한 코드 컨벤션과 디렉토리 구조가 규칙대로 정리되어있지 않아 아쉽다는 점이 있습니다.

오늘은 리드미를 좀 더 작성하고, 정리해보았습니다.  
디렉토리 구조를 작성할까 했는데, 글이 너무 복잡해지고 가독성이 떨어져서 일단 제외하기로 했습니다.  
대안을 고민하다 피그마를 사용해서 구조를 만들고 이미지로 올리는게 어떨까 하는데, 모든 구조를 담기에는 이미지의 크기가 작거나 이미지의 종류가 많아질 것 같아  결과적으로 똑같이 가독성이 좀 떨어지거나 복잡하게 보일 것 같아 리드미에 작성하지 않게 될 것 같습니다.

곧 발표일이 다가오는데 제가 발표를 담당하기로 했습니다.  
이제 내일 바로 ppt를 준비하고 발표에 대한 준비를 하고자 합니다.

오늘 추가로 히트마커를 구현했습니다.  
`TakeDamage`함수에서 `EventInstigator`가 플레이어 컨트롤러라면 특정 UI의 애니메이션을 재생하도록 구현했습니다.  
해당 기능도 지금까지 프로젝트에서 구현한 방법을 응용했습니다.