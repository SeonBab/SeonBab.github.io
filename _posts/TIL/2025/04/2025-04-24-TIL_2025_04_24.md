---
layout: single

title: "[TIL] 2025-04-24 알고리즘 문제, Nav Modifier Volume, MoveToActor, RVO"

categories:
    - TIL
tag: [TIL]

date: 2025-04-24
last_modified_at: 2025-04-24

order : 120
---

# 2025-04-24 TIL

## 알고리즘 문제

오늘 풀게된 알고리즘 문제도 수학적인 지식을 필요로 하는 문제라서 어렵게 느껴졌습니다.  
최대한 수학적인 부분을 이해하려고 노력했고, 최대한 자세하게 정리해 보았습니다.  
알고리즘 자체는 복잡하거나 구현에 난이도가 있지 않았기 때문에 수학적인 부분을 이해하고, 분석해본 후에는 쉽게 풀 수 있었습니다.  
수학적인 부분이 부족해서 문제를 풀 수 없는 일이 일어나지 않도록 노력해야겠습니다.  
[[프로그래머스][C++] 두 원 사이의 정수 쌍]({{ "/programmers/프로그래머스-두_원_사이의_정수_쌍/" | relative_url }}){: target="_blank"}

## Nav Modifier Volume

`Nav Modifier Volume`에서 `NavArea_Obstacle`을 지정하고, 굉장히 먼 거리를 이동하는 것에 대해서 다음과같이 생각 및 정보를 알아보고 정리해보았습니다.

우선 제가 알고있는 최단경로를 찾은 알고리즘을 기준으로 언리얼 엔진의 최단 경로를 생각한다면 다음과 같습니다.  

우선 첫 번째로, 누적된 이동 비용이 낮기 때문입니다.  
다익스트라 알고리즘이나 A* 알고리즘을 기준으로 생각했을 때, `Nav_Modifier_Volume`에 의해서 이동 비용이 올라가 있는 곳은 높은 가중치와 이동 거리로 누적 비용이 높게 잡혀있고, 돌아가는 길은 낮은 가중치와 이동 거리를 누적 했을 때 상대적으로 누적 비용이 낮아 크게 돌아가는 방법이 선택 됐라고 생각됩니다.  
즉, 가중치에 비해 돌아가는 이동 거리가 짧았기 때문에 돌아간거일 수 있다는 생각을 해봅니다.  
이 경우 돌아가는 경로의 이동 거리가 훨씬 길어지거나 가중치의 값이 낮아진다면 불륨을 뚫고 지나갈 수 있을 것 같습니다.  
위의 가정을 생각해본 뒤에 실제로 훨씬 더 먼 거리를 돌아가도록 수정해보아도 크게 돌아가는 경로가 선택됐습니다.

두 번째로, `Nav Modifier Volume`에서 `NavArea_Obstacle`을 지정됐다면 해당 영역은 기본적으로 경로를 찾을 때 우선 배제된다입니다.  
특정 변수나 값에 의해 기본적으로 경로를 찾을 때 해당 영역이 배제되어 최단 경로 계산에 후순위로 설정됐을 수 있을 것 같습니다.

일단 결과적으로 언리얼 엔진에서는 이런 결과가 나오도록 구현한 것이기 때문에 최대한 일어난 사실에 집중하고, 기억해두면 좋을 것 같습니다.

만약 결과를 수정하고 싶다면, 최단 경로를 만드는 로직에 대한 엔진 소스 코드를 살펴보는게 좋을 것 같습니다.  
하지만, 언리얼 엔진의 길찾기는 알고리즘이 공개되어있지 않아 알고리즘에 대해서 정확하게 알 수 없습니다.  
그렇기 때문에 길을 찾았다를 알리는 함수나 공개되어있는 소스 코드 중에서 최대한 살펴보는 것이 좋을 것 같습니다.

예를 들어, 비용을 무시하고 한번 더 길찾기를 진행해보아 길이가 얼마나 짧고, 비용이 얼마나 높은지를 비교해서 너무 돌아간다 싶으면 비용을 무시하고 간다거나 무시하고 가기에는 비용이 지나치게 높게 설정되어 있다면 돌아간다거나하는 로직을 직접 짜서 추가하는방법이 있는 것 같습니다.  
언리얼 엔진의 소스코드를 직접 살펴보고, 로직을 직접 짜서 추가하기에는 비용이 많이 들고 언리얼의 소스코드를 살펴보아 원하는 대로 동작하게 하는것은 현재로서 난이도가 지나치게 높다고 판단되어 현재로서는 이 방법을 직접 실행해보기에는 어려움이 있습니다.  
하지만, 나중에 이러한 문제에 부딪혀서 변화를 주어야하거나 근본적인 이유를 알아내야 한다면 오늘 생각해보고 정리해본 내용을 토대로 살펴볼 것 같습니다.

언리얼 엔진의 EQS를 사용해보는 방법도 있을 것 같은데, 아직 해당 기능에 대해서 정확하게 이해한 상태가 아니기 때문에 생각해보기에는 어려움이 있습니다.

## MoveToActor

어제 정리했던 AI에 이동 명령을 내리는 함수인 `MoveToLocation`와 `MoveToActor`의 차이점에 대해 부족한 점이 있어서 추가로 정리해보았습니다.  
`MoveToActor`함수는 대상을 일정 주기로 계속 추적한다는 것을 알게 되었다는 것과 그 결과로 연산 비용도 좀 더 많다는 것을 알았습니다.  
언리얼 엔진의 AI 이동 명령에 대해서 좀 더 살펴보다가 알게되었는데, 아직 새롭게 배우는 점이 많은 것 같고 학습할 때 좀 더 주의깊게 해야할 것 같습니다.  
[[UE5] AI 이동 명령 및 Nav Modifier Volume로 경로 바꾸기]({{ "/ue5dev/AI_Pathfinding/" | relative_url }}){: target="_blank"}

## RVO

RVO라는 기능 자체는 처음 보아서 많이 신기했습니다.  
해당 기능을 학습해보았기 때문에 직접 한번 사용해보는게 학습에 더 좋다고 판단해서 AI에 적용해서 충돌 회피를 해보았습니다.  
제가 적용한 방법에 부족함이 있었는지 잘 모르겠지만, AI캐릭터가 서로 밀어내기도 하다보니 네비메시가 비어있는 공간으로 밀려나기도 했고, 바로 적용하기에는 버그가 발생할 수 도 있을 것 같습니다.  
하지만, 이 기능을 사용하면 날아오는 장애물이나 AI끼리의 충돌을 방지할 수 있을 것 같습니다.  
제가 직접 구현해보고 적용해본 내용은 다른 게시물로 정리해서 작성해보았습니다.  
[[UE5] RVO]({{ "/ue5dev/RVO/" | relative_url }}){: target="_blank"}