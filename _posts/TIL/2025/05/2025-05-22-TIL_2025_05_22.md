---
layout: single

title: "[TIL] 2025-05-22 알고리즘 문제, UserWidget에 대한 기술적 의사 결정, 상호작용 트레이스 변경, 재료 아이템 및 인벤토리 구현"

categories:
    - TIL
tag: [TIL]

date: 2025-05-22
last_modified_at: 2025-05-22

order : 144
---

# 2025-05-22 TIL

## 알고리즘 문제

이번 문제는 동적 계획법(DP)인 카데인 알고리즘으로 풀 수 있는 문제였습니다.  
동적 계획법에 대해서 학습을 거의 하지 못했고, 부족한 부분이 많아서 풀어내지는 못했습니다.  
이 문제는 시간이 나중에 있다면 동적 계획법에 대해서 제대로 학습한 후에 문제를 다시 풀어보는 것이 가장 좋을 것 같습니다.  
[[프로그래머스][C++] 연속 펄스 부분 수열의 합]({{ "/programmers/프로그래머스-연속_펄스_부분_수열의_합/" | relative_url }}){: target="_blank"}

## 최종 프로젝트

오늘은 다음과 같은 작업을 수행했습니다.

1. UserWidget에 대한 기술적 의사 결정
2. 플레이어 캐릭터의 상호작용 트레이스 로직 변경
3. 몬스터가 죽었을 때 드랍될 재료 아이템 액터 구현
4. 플레이어 캐릭터의 재료 인벤토리 구현
5. 팀원의 작업 리마인드 및 추가

### UserWidget에 대한 기술적 의사 결정

UI에 대해서 관리할 객체를 정할 때, 컴포넌트가 UI를 가지고 관리할지 플레이어 컨트롤러가 가지고 관리할지 두가지 방향이 있었습니다.

결과적으로 플레이어 컨트롤러가 UI를 관리하도록 했습니다.  
이유는 다음과 같습니다.

+ 컴포넌트가 데이터를 관리하는데 UI까지 관리하면 책임이 크다는 이유가 있습니다.
+ UI를 컴포넌트가 가지고 관리하게 되는 경우, 코드가 불필요하게 복잡해진다는 문제가 있습니다.
+ 멀티게임은 아니지만 UI는 일반적으로 플레이어 컨트롤러가 관리하는 것이 언리얼엔진의 권장 구조입니다.

다른 문제로 UI는 플레이어 컨트롤러가 관리하는데, UI의 갱신이 필요한 경우 플레이어 컨트롤러를 통해 UI를 직접 참조할지, 이벤트 디스패처를 사용하여 UI를 바인딩하고, 이벤트를 호출할지에 대한 방향이 있었습니다.

결과적으로 델리게이트를 통한 이벤트 디스패처를 사용하기로 했습니다.  
이유는 다음과 같습니다.

+ 컴포넌트가 UI를 사용하지 않는 이유와 비슷하게 코드가 불필요하게 복잡해진다는 문제가 있습니다.
+ 불필요하게 다른 클래스에 대한 정보를 가지고있어야하는 의존성 문제가 생깁니다.
+ 성능적인 면으로도 이벤트 디스패처가 유리하다고 판단했습니다.

### 플레이어 캐릭터의 상호작용 트레이스 로직 변경

기존 플레이어 캐릭터는 라인 트레이스를 사용하여 충돌된 액터를 찾는데, 다른 액터의 충돌체 크기가 너무 작은 경우 충돌되지 않는다는 문제가 발생했기 때문에 변경했습니다.

`OverlapMultiByChannel`함수를 사용하여 캐릭터를 중심으로 원 모양으로 충돌을 체크합니다.

첫 번째로 전방 방향 중 가장 가까운 액터와 상호작용 합니다.  
두 번째로 전방 방향 중 가장 가까운 액터가 없을 때 오버랩 된 액터 중 가장 가까운 액터와 상호작용 합니다.

이 방법으로 라인 트레이스의 충돌 문제를 해결했고, 플레이어 캐릭터가 액터를 정확하게 바라보지 않아도 상호작용을 할 수 있게 됐습니다.  

### 재료 아이템 액터 구현

이전에 무기 액터를 바닥에 버리도록 구현한 로직과 유사한 점이 많았습니다.  
대표적으로, 데이터 테이블의 RowName을 FName으로 저장하는 점, 데이터 테이블에 정의된 StaticMesh로 액터를 세팅한다는 점 등이 있습니다.  
그렇기 때문에 상속 관계를 가지도록 구현할 예정입니다.  
우선 프로토타이핑 기간이며 23일에 팀 내부의 간이 시연회를 가질 예정이기 때문에 빠르게 구현해두었습니다.

인벤토리를 구현하기 전에 액터를 구현했기 때문에 아직 플레이어의 인벤토리로 들어갈 수 있도록 로직을 구현하지는 않았습니다.

### 인벤토리 구현

플레이어의 인벤토리를 컴포넌트를 사용하여 구현했습니다.  
기본적으로 있어야하는 함수나 변수들은 팀원 중 한분이 베이스를 준비해주었습니다.  
그렇기 때문에 준비된 베이스에서 구체적인 로직을 구현했습니다.  
던전과 타이쿤 두 경우 모두에서 인벤토리가 필요하기 때문에 상속 관계를 가지도록 하여 분리해주었습니다.

구현한 로직은 다음과 같습니다.

+ 인벤토리의 슬롯에는 재료 아이템이 들어가게 되며, 같은 재료 아이템을 먹었을 경우 기존에 있던 슬롯에서 개수가 증가하도록 구현했습니다.
+ 인벤토리에 들어있는 아이템을 버리거나, 제거하는 함수 또한 구현했습니다.
+ 기타 Get/Set

### 팀원의 작업 리마인드 및 추가

일부 팀원들의 작업이 마무리되어감에 따라 다음 작업을 분배해주었습니다.

AI의 경우 부족한 부분에 대해서 이야기를 하여 퀄리티를 좀 더 올리도록했고, 구현되지 않은 부분에 대해 다시 되짚어보았습니다.

이외에 실력이 부족한 팀원은 상대적으로 쉬운 작업을 분배했습니다.  
플레이어 캐릭터로 사용할 메시가 모듈식으로 되어있었는데, 이 모듈로 이루어진 메시를 플레이어 캐릭터에 적용하도록 작업을 분배하였습니다.