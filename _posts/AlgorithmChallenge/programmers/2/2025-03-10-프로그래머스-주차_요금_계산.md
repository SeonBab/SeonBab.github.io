---
layout: single

title: "[프로그래머스][C++] 주차 요금 계산"

categories:
    - Programmers
tag: [프로그래머스]

date: 2025-03-10
last_modified_at: 2025-03-10

order : 92341
---

# 문제

주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.

+ 요금표

|기본 시간(분)|기본 요금(원)|단위 시간(분)|단위 요금(원)|
|---|---|---|
|180|5000|10|600|

+ 입/출차 기록

|시각(시:분)|차량 번호|내역|
|---|---|---|
|05:34|5961|입차|
|06:00|0000|입차|
|06:34|0000|출차|
|07:59|5961|출차|
|07:59|0148|입차|
|18:59|0000|입차|
|19:09|0148|출차|
|22:59|5961|입차|
|23:00|5961|출차|

+ 자동차별 주차 요금

|차량 번호|누적 주차 시간(분)|주차 요금(원)|
|---|---|---|
|0000|34 + 300 = 334|5000 + `⌈`(334 - 180) / 10`⌉` x 600 = 14600|
|0148|670|5000 +`⌈`(670 - 180) / 10`⌉`x 600 = 34400|
|5961|145 + 1 = 146|5000|

+ 어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.
    + `0000`번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.
+ 00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.
+ 누적 주차 시간이 `기본 시간`이하라면, `기본 요금`을 청구합니다.
+ 누적 주차 시간이 `기본 시간`을 초과하면, `기본 요금`에 더해서, 초과한 시간에 대해서 `단위 시간` 마다 `단위 요금`을 청구합니다.
    + 초과한 시간이 `단위 시간`으로 나누어 떨어지지 않으면, `올림`합니다.
    + `⌈`a`⌉` : a보다 작지 않은 최소의 정수를 의미합니다. 즉, `올림`을 의미합니다.
주차 요금을 나타내는 정수 배열 `fees`, 자동차의 입/출차 내역을 나타내는 문자열 배열 `records`가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

## 제한사항

+ `fees`의 길이 = 4
    + fees[0] = `기본 시간(분)`
    + 1 ≤ fees[0] ≤ 1,439
    + fees[1] = `기본 요금(원)`
    + 0 ≤ fees[1] ≤ 100,000
    + fees[2] = `단위 시간(분)`
    + 1 ≤ fees[2] ≤ 1,439
    + fees[3] = `단위 요금(원)`
    + 1 ≤ fees[3] ≤ 10,000

+ 1 ≤ `records`의 길이 ≤ 1,000
    + `records`의 각 원소는 `"시각 차량번호 내역"` 형식의 문자열입니다.
    + `시각`, `차량번호`, `내역`은 하나의 공백으로 구분되어 있습니다.
    + `시각`은 차량이 입차되거나 출차된 시각을 나타내며, `HH:MM` 형식의 길이 5인 문자열입니다.
        + `HH:MM`은 00:00부터 23:59까지 주어집니다.
        + 잘못된 시각("25:22", "09:65" 등)은 입력으로 주어지지 않습니다.
    + `차량번호`는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다.
    + `내역`은 길이 2 또는 3인 문자열로, `IN` 또는 `OUT`입니다. `IN`은 입차를, `OUT`은 출차를 의미합니다.
    + `records`의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다.
    + `records`는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다.
    + 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다.
    + 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다.
    + 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.
        + 주차장에 없는 차량이 출차되는 경우
        + 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우

## 입출력 예

|fees|records|result|
|---|---|---|
|[180, 5000, 10, 600]|`["05:34 5961 IN", "06:00 0000 IN", "06:34 0000 OUT", "07:59 5961 OUT", "07:59 0148 IN", "18:59 0000 IN", "19:09 0148 OUT", "22:59 5961 IN", "23:00 5961 OUT"]`|[14600, 34400, 5000]|
|[120, 0, 60, 591]|`["16:00 3961 IN","16:00 0202 IN","18:00 3961 OUT","18:00 0202 OUT","23:58 3961 IN"]`|[0, 591]|
|[1, 461, 1, 10]|`["00:00 1234 IN"]`|[14841]|

입출력 예 #1  
문제 예시와 같습니다.

입출력 예 #2  
+ 요금표

|기본 시간(분)|기본 요금(원)|단위 시간(분)|단위 요금(원)|
|---|---|---|
|120|0|60|591|

+ 입/출차 기록

|시각(시:분)|차량 번호|내역|
|---|---|---|
|16:00|3961|입차|
|16:00|0202|입차|
|18:00|3961|출차|
|18:00|0202|출차|
|23:58|3961|입차|

+ 자동차별 주차 요금

|차량 번호|누적 주차 시간(분)|주차 요금(원)|
|---|---|---|
|0202|120|5000 + ⌈0|
|3961|120 + 1 = 121|0 +`⌈`(121 - 120) / 60`⌉`x 591 = 591|

+ 3961번 차량은 2번째 입차된 후에는 출차된 내역이 없으므로, 23:59에 출차되었다고 간주합니다.

입출력 예 #3  
+ 요금표

|기본 시간(분)|기본 요금(원)|단위 시간(분)|단위 요금(원)|
|---|---|---|
|1|461|1|10|

+ 입/출차 기록

|시각(시:분)|차량 번호|내역|
|---|---|---|
|00:00|1234|입차|

+ 자동차별 주차 요금

|차량 번호|누적 주차 시간(분)|주차 요금(원)|
|---|---|---|
|1234|1439|	461 +`⌈`(1439 - 1) / 1`⌉`x 10 = 14841|

+ `1234`번 차량은 출차 내역이 없으므로, 23:59에 출차되었다고 간주합니다.

## 분석

주차 요금을 계산하는 문제입니다.

차량별 누적 주차 시간을 계산해야합니다.  
기본 시간을 초과한 경우 단위 시간 단위로 추가 요금을 계산합니다.  
출차 기록이 없는 경우 `23:59` 출차로 처리합니다.


## 풀이

```cpp
#include <string>
#include <vector>
#include <map>
#include <sstream>
#include <cmath>

using namespace std;

// records의 시간을 분으로 변환
int timeToMinutes(const string& time)
{
    // 시
    int hours = stoi(time.substr(0, 2));
    // 분
    int minutes = stoi(time.substr(3, 2));
    
    return hours * 60 + minutes;
}

vector<int> solution(vector<int> fees, vector<string> records) {
    vector<int> answer;
    
    // 주차된 총 시간
    map<string, int> parkingTime;
    // 입차 시간
    map<string, int> inTime;
    
    // 입/출차 순회
    for (const auto& record : records)
    {
        // 문자열을 분리하기위해 사용
        stringstream ss(record);

        // 분리한 문자열 저장할 변수
        string time;
        string carNumber;
        string info;

        // 시간, 차량 번호, 입/출차 기록으로 분리
        ss >> time >> carNumber >> info;
        
        // 시간을 분으로 변환
        int minutes = timeToMinutes(time);
        
        if (info == "IN")
        {
            // 입차인 경우 입차 시간을 분으로 저장
            inTime[carNumber] = minutes;
        }
        else
        {
            // 출차인 경우 출차 시간 - 입차 시간으로 주차된 시간을 구하고 저장
            parkingTime[carNumber] += minutes - inTime[carNumber];
            inTime.erase(carNumber);
        }
    }
    
    // 입차 기록만 있고 출차 기록이 없는 차량 처리
    for (const auto& e : inTime)
    {
        // 출차 시간 - 입차 시간으로 주차된 시간을 구하고 저장
        parkingTime[e.first] += timeToMinutes("23:59") - e.second;
    }
    
    // 각 차량별로 주차된 시간을 순회해서 요금으로 변환
    for (const auto& e : parkingTime)
    {        
        int fee = 0;
        if (e.second <= fees[0])
        {
            // 주차한 시간이 기본 시간보다 적은 경우 기본 요금
            fee = fees[1];
        }
        else
        {
            // 주차한 시간이 기본 시간보다 많은 경우
            // 기본 시간에 대한 요금과 단위 시간에 대한 요금을 계산
            fee = fees[1] + ceil((double)(e.second - fees[0]) / fees[2]) * fees[3];
        }
        
        answer.push_back(fee);
    }
    
    return answer;
}
```

## 성능 요약

시간 복잡도는 $O(n)$입니다.

- `records`를 순회하는 반복문 $O(n)$
- `inTime`를 순회하는 반복문 $O(m)$
- `parkingTime`를 순회하는 반복문 $O(m)$
- $O(n + m + m)$

공간 복잡도는 $O(m)$입니다.

- 주차된 총 시간을 저장하는 `parkingTime` $O(m)$
- 주차 중인 차량들의 입차 시간을 저장하는 `inTime` $O(m)$
- 반환될 값을 저장하는 `answer` $O(m)$
- $O(m)$

테스트 1 〉 통과 (0.03ms, 4.16MB)  
테스트 2 〉 통과 (0.03ms, 4.21MB)  
테스트 3 〉 통과 (0.04ms, 4.2MB)  
테스트 4 〉 통과 (0.11ms, 4.21MB)  
테스트 5 〉 통과 (0.15ms, 4.21MB)  
테스트 6 〉 통과 (0.15ms, 4.2MB)  
테스트 7 〉 통과 (1.24ms, 3.91MB)  
테스트 8 〉 통과 (0.72ms, 4.2MB)  
테스트 9 〉 통과 (0.23ms, 4.21MB)  
테스트 10 〉 통과 (1.05ms, 4.21MB)  
테스트 11 〉 통과 (1.88ms, 4.21MB)  
테스트 12 〉 통과 (1.42ms, 3.95MB)  
테스트 13 〉 통과 (0.05ms, 3.64MB)  
테스트 14 〉 통과 (0.03ms, 4.21MB)  
테스트 15 〉 통과 (0.02ms, 4.14MB)  
테스트 16 〉 통과 (0.03ms, 4.21MB)  

## 문제 링크

[주차 요금 계산](https://school.programmers.co.kr/learn/courses/30/lessons/92341){: target="_blank"}