---
layout: single

title: "[프로그래머스][C++] 성격 유형 검사하기"

categories:
    - Programmers
tag: [프로그래머스]

date: 2025-02-09
last_modified_at: 2025-02-09

order : 118666
---

# 성격 유형 검사하기

## 문제 링크

[성격 유형 검사하기](https://school.programmers.co.kr/learn/courses/30/lessons/118666){: target="_blank"}

## 제한사항

1 ≤ `survey`의 길이 ( = n) ≤ 1,000  
`survey`의 원소는 `"RT", "TR", "FC", "CF", "MJ", "JM", "AN", "NA"` 중 하나입니다.  
`survey[i]`의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.  
`survey[i]`의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.

`choices`의 길이 = `survey`의 길이  
`choices[i]`는 검사자가 선택한 i+1번째 질문의 선택지를 의미합니다.  
1 ≤ `choices`의 원소 ≤ 7

|`choices`|뜻|
|---|---|
|1|매우 비동의|
|2|비동의|
|3|약간 비동의|
|4|모르겠음|
|5|약간 동의|
|6|동의|
|7|매우 동의|

## 입출력 예

|survey|choices|result|
|---|---|---|
|`["AN", "CF", "MJ", "RT", "NA"]`|[5, 3, 2, 7, 5]|`"TCMA"`|
|`["TR", "RT", "TR"]`|[7, 1, 3]|`"RCJA"`|

입출력 예 #1  
1번 질문의 점수 배치는 아래 표와 같습니다.

|선택지|성격 유형 점수|
|---|---|
|매우 비동의|어피치형 3점|
|비동의|어피치형 2점|
|약간 비동의|어피치형 1점|
|모르겠음|어떤 성격 유형도 점수를 얻지 않습니다|
|**약간 동의**|**네오형 1점**|
|동의|네오형 2점|
|매우 동의|네오형 3점|

1번 질문에서는 지문의 예시와 다르게 비동의 관련 선택지를 선택하면 어피치형(A) 성격 유형의 점수를 얻고, 동의 관련 선택지를 선택하면 네오형(N) 성격 유형의 점수를 얻습니다.  
1번 질문에서 검사자는 `약간 동의` 선택지를 선택했으므로 네오형(N) 성격 유형 점수 1점을 얻게 됩니다.

2번 질문의 점수 배치는 아래 표와 같습니다.

|선택지|성격 유형 점수|
|---|---|
|매우 비동의|콘형 3점|
|비동의|콘형 2점|
|**약간 비동의**|**콘형 1점**|
|모르겠음|어떤 성격 유형도 점수를 얻지 않습니다|
|약간 동의|프로도형 1점|
|동의|프로도형 2점|
|매우 동의|프로도형 3점|

2번 질문에서 검사자는 `약간 비동의` 선택지를 선택했으므로 콘형(C) 성격 유형 점수 1점을 얻게 됩니다.

3번 질문의 점수 배치는 아래 표와 같습니다.

|선택지|성격 유형 점수|
|---|---|
|매우 비동의|무지형 3점|
|**비동의**|**무지형 2점**|
|약간 비동의|무지형 1점|
|모르겠음|어떤 성격 유형도 점수를 얻지 않습니다|
|약간 동의|제이지형 1점|
|동의|제이지형 2점|
|매우 동의|제이지형 3점|

3번 질문에서 검사자는 `비동의` 선택지를 선택했으므로 무지형(M) 성격 유형 점수 2점을 얻게 됩니다.

4번 질문의 점수 배치는 아래 표와 같습니다.

|선택지|성격 유형 점수|
|---|---|
|매우 비동의|라이언형 3점|
|비동의|라이언형 2점|
|약간 비동의|라이언형 1점|
|모르겠음|어떤 성격 유형도 점수를 얻지 않습니다|
|약간 동의|튜브형 1점|
|동의|튜브형 2점|
|**매우 동의**|**튜브형 3점**|

4번 질문에서 검사자는 `매우 동의` 선택지를 선택했으므로 튜브형(T) 성격 유형 점수 3점을 얻게 됩니다.

5번 질문의 점수 배치는 아래 표와 같습니다.

|선택지|성격 유형 점수|
|---|---|
|매우 비동의|네오형 3점|
|비동의|네오형 2점|
|약간 비동의|네오형 1점|
|모르겠음|어떤 성격 유형도 점수를 얻지 않습니다|
|**약간 동의**|**어피치형 1점**|
|동의|어피치형 2점|
|매우 동의|어피치형 3점|

5번 질문에서 검사자는 `약간 동의` 선택지를 선택했으므로 어피치형(A) 성격 유형 점수 1점을 얻게 됩니다.

1번부터 5번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다.

|지표 번호|성격 유형|점수|성격 유형|점수|
|---|---|---|---|---|
|1번 지표|라이언형(R)|0|튜브형(T)|3|
|2번 지표|콘형(C)|1|프로도형(F)|0|
|3번 지표|제이지형(J)|0|무지형(M)|2|
|4번 지표|어피치형(A)|1|네오형(N)|1|

각 지표에서 더 점수가 높은 `T`,`C`,`M`이 성격 유형입니다.  
하지만, 4번 지표는 1점으로 동일한 점수입니다.  
따라서, 4번 지표의 성격 유형은 사전순으로 빠른 A입니다.

따라서 `"TCMA"`를 return 해야 합니다.

입출력 예 #2  

1번부터 3번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다.

|지표 번호|성격 유형|점수|성격 유형|점수|
|---|---|---|---|---|
|1번 지표|라이언형(R)|6|튜브형(T)|1|
|2번 지표|콘형(C)|0|프로도형(F)|0|
|3번 지표|제이지형(J)|0|무지형(M)|0|
|4번 지표|어피치형(A)|0|네오형(N)|0|

1번 지표는 튜브형(T)보다 라이언형(R)의 점수가 더 높습니다.  
따라서 첫 번째 지표의 성격 유형은 `R`입니다.  
하지만, 2, 3, 4번 지표는 모두 0점으로 동일한 점수입니다.  
따라서 2, 3, 4번 지표의 성격 유형은 사전순으로 빠른 `C`, `J`, `A`입니다.

따라서 `"RCJA"`를 return 해야 합니다.

## 분석

8개의 성격 유형(R, T, C, F, J, M, A, N)이 있습니다.  
한 질문에서 2가지 성격 유형이 묶여 4개의 지표로 구분합니다.  
4개의 지표는 (RT, CF, JM, AN)이 있습니다.  
지표의 성격 유형은 순서가 바뀔 수 있습니다. (TR, FC, MJ, NA)

선택지는 7가지로, 성격 유형에 대해 0 ~ 3점을 얻습니다.  
검사자의 선택이 3번째 이하의 선택지라면 지표의 왼쪽 성격 유형이 값을 얻습니다.  
검사자의 선택이 5번째 이상의 선택지라면 지표의 오른쪽 성격 유형이 값을 얻습니다.

지표에서 각 성격 유형 중 점수가 높은 쪽이 선택됩니다.  
만약 점수가 같은 경우 사전순으로 빠른 쪽이 선택됩니다.

## 풀이

```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

string solution(vector<string> survey, vector<int> choices) {
    string answer = "";
    
    // 선택지를 점수로 치환하기 위한 배열
    int score[7] {3, 2, 1, 0, 1, 2, 3};
    // 각 성격 유형에 대한 점수 저장
    unordered_map<char, int> totalScores;
    
    for (int i = 0; i < survey.size(); ++i)
    {
        // 선택지를 점수로 치환
        // 검사자의 선택은 i+1입니다.
        int choice = choices[i] - 1;
        int choiceScore = score[choice];
        
        // 검사자가 3번째 이하의 선택지를 선택한 경우
        if (choice < 3)
        {
            // 왼쪽 성격 유형 값 증가
            char typeA = survey[i][0];
            totalScores[typeA] += choiceScore;
        }
        // 검사자가 5번째 이상의 선택지를 선택한 경우
        else if (choice > 3)
        {
            // 오른쪽 성격 유형 값 증가
            char typeB = survey[i][1];
            totalScores[typeB] += choiceScore;
        }   
    }
    
    // 지표에 대해 성격 유형 중 점수가 높고 사전순으로 빠른 쪽을 구합니다.
    answer += (totalScores['R'] >= totalScores['T']) ? 'R' : 'T';
    answer += (totalScores['C'] >= totalScores['F']) ? 'C' : 'F';
    answer += (totalScores['J'] >= totalScores['M']) ? 'J' : 'M';
    answer += (totalScores['A'] >= totalScores['N']) ? 'A' : 'N';
    
    return answer;
}
```

`score`배열은 검사자의 선택을 점수로 바꾸는데 다른 방법으로, 검사자의 선택 값에 `-4`를 하고 절대값으로 변경하면 해당 배열과 같은 값을 얻을 수 있습니다.

```cpp
abs(choices[i] - 4);
```

`unordered_map<char, int> totalScores`은 각 성격 유형을 키로 점수를 관리하기 위해 사용했습니다.

## 성능 요약

시간 복잡도는 $O(n)$입니다.

- `survey`를 순회하는 반복문 $O(n)$

공간 복잡도는 $O(1)$입니다.

- 각 성격 유형의 점수를 저장하는 `totalScores` $O(1)$
- 선택지를 점수로 치환하기 위한 배열 `score` $O(1)$
- 결과값을 저장하는 `answer` $O(1)$

테스트 1 〉 통과 (0.01ms, 4.21MB)  
테스트 2 〉 통과 (0.01ms, 4.19MB)  
테스트 3 〉 통과 (0.01ms, 4.13MB)  
테스트 4 〉 통과 (0.01ms, 4.11MB)  
테스트 5 〉 통과 (0.01ms, 4.12MB)  
테스트 6 〉 통과 (0.01ms, 3.61MB)  
테스트 7 〉 통과 (0.01ms, 4.13MB)  
테스트 8 〉 통과 (0.01ms, 4.08MB)  
테스트 9 〉 통과 (0.01ms, 4.21MB)  
테스트 10 〉 통과 (0.02ms, 3.67MB)  
테스트 11 〉 통과 (0.02ms, 4.19MB)  
테스트 12 〉 통과 (0.02ms, 4.01MB)  
테스트 13 〉 통과 (0.03ms, 4.04MB)  
테스트 14 〉 통과 (0.04ms, 4.2MB)  
테스트 15 〉 통과 (0.05ms, 4.13MB)  
테스트 16 〉 통과 (0.06ms, 3.71MB)  
테스트 17 〉 통과 (0.06ms, 4.13MB)  
테스트 18 〉 통과 (0.07ms, 3.77MB)  
테스트 19 〉 통과 (0.06ms, 4.2MB)  
테스트 20 〉 통과 (0.08ms, 4.13MB)  