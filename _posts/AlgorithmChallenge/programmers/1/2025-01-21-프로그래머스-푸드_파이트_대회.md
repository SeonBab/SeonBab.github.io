---
layout: single

title: "[프로그래머스][C++] 푸드 파이트 대회"

categories:
    - Programmers
tag: [프로그래머스]

date: 2025-01-21
last_modified_at: 2025-01-21

order : 134240
---

# 문제

수웅이는 매달 주어진 음식을 빨리 먹는 푸드 파이트 대회를 개최합니다.  
이 대회에서 선수들은 1대 1로 대결하며, 매 대결마다 음식의 종류와 양이 바뀝니다.  
대결은 준비된 음식들을 일렬로 배치한 뒤, 한 선수는 제일 왼쪽에 있는 음식부터 오른쪽으로, 다른 선수는 제일 오른쪽에 있는 음식부터 왼쪽으로 순서대로 먹는 방식으로 진행됩니다. 중앙에는 물을 배치하고, 물을 먼저 먹는 선수가 승리하게 됩니다.

이때, 대회의 공정성을 위해 두 선수가 먹는 음식의 종류와 양이 같아야 하며, 음식을 먹는 순서도 같아야 합니다.  
또한, 이번 대회부터는 칼로리가 낮은 음식을 먼저 먹을 수 있게 배치하여 선수들이 음식을 더 잘 먹을 수 있게 하려고 합니다.  
이번 대회를 위해 수웅이는 음식을 주문했는데, 대회의 조건을 고려하지 않고 음식을 주문하여 몇 개의 음식은 대회에 사용하지 못하게 되었습니다.

예를 들어, 3가지의 음식이 준비되어 있으며, 칼로리가 적은 순서대로 1번 음식을 3개, 2번 음식을 4개, 3번 음식을 6개 준비했으며, 물을 편의상 0번 음식이라고 칭한다면, 두 선수는 1번 음식 1개, 2번 음식 2개, 3번 음식 3개씩을 먹게 되므로 음식의 배치는 "1223330333221"이 됩니다.  
따라서 1번 음식 1개는 대회에 사용하지 못합니다.

수웅이가 준비한 음식의 양을 칼로리가 적은 순서대로 나타내는 정수 배열 food가 주어졌을 때, 대회를 위한 음식의 배치를 나타내는 문자열을 return 하는 solution 함수를 완성해주세요.

## 제한사항

+ 2 ≤ `food`의 길이 ≤ 9
+ 1 ≤ `food`의 각 원소 ≤ 1,000
+ `food`에는 칼로리가 적은 순서대로 음식의 양이 담겨 있습니다.
+ `food[i]`는 i번 음식의 수입니다.
+ `food[0]`은 수웅이가 준비한 물의 양이며, 항상 1입니다.
+ 정답의 길이가 3 이상인 경우만 입력으로 주어집니다.

## 입출력 예

|food|result|
|---|---|
|[1, 3, 4, 6]|"1223330333221"|
|[1, 7, 1, 2]|"111303111"|

입출력 예 #1  
문제 예시와 같습니다.

입출력 예 #2  
두 선수는 1번 음식 3개, 3번 음식 1개를 먹게 되므로 음식의 배치는 "111303111"입니다.

## 분석

배열의 2번째 요소부터 2로 나눠 몫의 크기만큼 요소의 인덱스를 문자열로 추가하는 문제입니다.

예를 들어 입출력 예 #2의 경우 2번째 인덱스에 7이므로 $7 \div 2$를 하면 몫은 3입니다.  
몫이 3이므로 3번 1을 추가합니다.

이렇게 각 배열의 요소를 확인해 문자를 추가하며, 문자열의 중앙에 0이 있어야 합니다.

문자열의 왼쪽 부분을 만들고 오른쪽 부분은 왼쪽 부분을 거꾸로 순회해 추가하는 방법으로 문제를 풀이할 수 있습니다.  
또한 문자열의 중앙부터 양쪽으로 문자를 동시에 추가하는 방법으로 문제를 풀이할 수 있습니다.

## 풀이

왼쪽 부분을 만들고 오른쪽 부분은 거꾸로 순회해 추가한 방법입니다.

```cpp
#include <string>
#include <vector>

using namespace std;

string solution(vector<int> food) {
    string answer = "";
    
    for (int i = 1; i < food.size(); ++i)
    {
        int loopCount = food[i] / 2;
        for (int j = 0; j < loopCount; ++j)
        {
            answer += to_string(i);
        }
    }
    
    answer += '0';
    
    for (int i = answer.length() - 2; i >= 0; --i)
    {
        answer += answer[i];
    }
    
    return answer;
}
```

첫 반복문에서 왼쪽 문자열을 생성합니다.

규칙에 따라 중앙에 물을 의미하는 '0'을 배치합니다.

두 번째 반복문에서 오른쪽 문자열을 생성합니다.

---

양쪽의 문자를 동시에 추가하는 방법입니다.

```cpp
#include <string>
#include <vector>

using namespace std;

string solution(vector<int> food) {
    string answer = "0";
    
    for (int i = food.size() - 1; i > 0 ; --i)
    {
        int loopCount = food[i] / 2;
        for (int j = 0; j < loopCount; ++j)
        {
            answer = to_string(i) + answer + to_string(i);
        }
    }
    
    return answer;
}
```

## 성능 요약

왼쪽 부분을 만들고 오른쪽 부분은 거꾸로 순회해 추가한 방법의 성능입니다.

테스트 1 〉 통과 (0.10ms, 4.14MB)  
테스트 2 〉 통과 (0.11ms, 4.18MB)  
테스트 3 〉 통과 (0.10ms, 3.77MB)  
테스트 4 〉 통과 (0.15ms, 4.14MB)  
테스트 5 〉 통과 (0.04ms, 3.71MB)  
테스트 6 〉 통과 (0.17ms, 4.02MB)  
테스트 7 〉 통과 (0.16ms, 4.13MB)  
테스트 8 〉 통과 (0.18ms, 4.14MB)  
테스트 9 〉 통과 (0.06ms, 3.77MB)  
테스트 10 〉 통과 (0.06ms, 4.21MB)  
테스트 11 〉 통과 (0.01ms, 4.21MB)  
테스트 12 〉 통과 (0.02ms, 4.21MB)  
테스트 13 〉 통과 (0.01ms, 4.2MB)  
테스트 14 〉 통과 (0.28ms, 4.03MB)  
테스트 15 〉 통과 (0.01ms, 4.16MB)  
테스트 16 〉 통과 (0.01ms, 4.2MB)  
테스트 17 〉 통과 (0.01ms, 4.14MB)  
테스트 18 〉 통과 (0.01ms, 4.2MB)  
테스트 19 〉 통과 (0.01ms, 4.16MB)  
테스트 20 〉 통과 (0.02ms, 4.21MB)  

---

양쪽의 문자를 동시에 추가하는 방법의 성능입니다.

테스트 1 〉 통과 (0.42ms, 4.11MB)  
테스트 2 〉 통과 (0.76ms, 3.96MB)  
테스트 3 〉 통과 (0.66ms, 4.2MB)  
테스트 4 〉 통과 (0.87ms, 4.14MB)  
테스트 5 〉 통과 (0.12ms, 4.19MB)  
테스트 6 〉 통과 (0.65ms, 4.2MB)  
테스트 7 〉 통과 (1.13ms, 4.16MB)  
테스트 8 〉 통과 (0.38ms, 4.2MB)  
테스트 9 〉 통과 (0.39ms, 4.16MB)  
테스트 10 〉 통과 (0.42ms, 3.77MB)  
테스트 11 〉 통과 (0.01ms, 4.2MB)  
테스트 12 〉 통과 (0.01ms, 4.21MB)  
테스트 13 〉 통과 (0.01ms, 4.21MB)  
테스트 14 〉 통과 (1.96ms, 3.71MB)  
테스트 15 〉 통과 (0.01ms, 4.2MB)  
테스트 16 〉 통과 (0.01ms, 4.14MB)  
테스트 17 〉 통과 (0.01ms, 4.2MB)  
테스트 18 〉 통과 (0.02ms, 3.68MB)  
테스트 19 〉 통과 (0.01ms, 4.2MB)  
테스트 20 〉 통과 (0.02ms, 4.2MB)  

## 문제 링크

[푸드 파이트 대회](https://school.programmers.co.kr/learn/courses/30/lessons/134240){: target="_blank"}