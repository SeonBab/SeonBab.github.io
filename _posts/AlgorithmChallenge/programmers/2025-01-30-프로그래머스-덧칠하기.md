---
layout: single

title: "프로그래머스 덧칠하기"

categories:
    - Programmers
tag: [프로그래머스]

date: 2025-01-30
last_modified_at: 2025-01-30

order : 161989
---

# 문제

어느 학교에 페인트가 칠해진 길이가 n미터인 벽이 있습니다.  
벽에 동아리 · 학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해 테이프로 붙였다가 철거할 때 떼는 일이 많고 그 과정에서 페인트가 벗겨지곤 합니다.  
페인트가 벗겨진 벽이 보기 흉해져 학교는 벽에 페인트를 덧칠하기로 했습니다.

넓은 벽 전체에 페인트를 새로 칠하는 대신, 구역을 나누어 일부만 페인트를 새로 칠 함으로써 예산을 아끼려 합니다.  
이를 위해 벽을 1미터 길이의 구역 n개로 나누고, 각 구역에 왼쪽부터 순서대로 1번부터 n번까지 번호를 붙였습니다.  
그리고 페인트를 다시 칠해야 할 구역들을 정했습니다.

벽에 페인트를 칠하는 롤러의 길이는 m미터이고, 롤러로 벽에 페인트를 한 번 칠하는 규칙은 다음과 같습니다.

롤러가 벽에서 벗어나면 안 됩니다.  
구역의 일부분만 포함되도록 칠하면 안 됩니다.  
즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다.  
현재 페인트를 칠하는 구역들을 완전히 칠한 후 벽에서 롤러를 떼며, 이를 벽을 한 번 칠했다고 정의합니다.

한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야 합니다.  
예산을 아끼기 위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다.

정수 `n`, `m`과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열 `section`이 매개변수로 주어질 때 롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요.

## 제한사항

1 ≤ `m` ≤ `n` ≤ 100,000

1 ≤ `section`의 길이 ≤ `n`  
1 ≤ `section`의 원소 ≤ `n`  
`section`의 원소는 페인트를 다시 칠해야 하는 구역의 번호입니다.  
`section`에서 같은 원소가 두 번 이상 나타나지 않습니다.  
`section`의 원소는 오름차순으로 정렬되어 있습니다.

## 입출력 예

|n|m|section|result|
|---|---|---|
|8|4|[2, 3, 6]|2|
|5|4|[1, 3]|1|
|4|1|[1, 2, 3, 4]|4|

입출력 예 #1  
예제 1번은 2, 3, 6번 영역에 페인트를 다시 칠해야 합니다.  
롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있습니다.  
처음에 3, 4, 5, 6번 영역에 페인트칠을 하면 칠해야 할 곳으로 2번 구역만 남고 1, 2, 3, 4번 구역에 페인트칠을 하면 2번 만에 다시 칠해야 할 곳에 모두 페인트칠을 할 수 있습니다.

![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/7e657b3f-1e5b-4724-b053-9548b2cd17ba/img1.png)

2번보다 적은 횟수로 2, 3, 6번 영역에 페인트를 덧칠하는 방법은 없습니다. 따라서 최소 횟수인 2를 return 합니다.

입출력 예 #2  
예제 2번은 1, 3번 영역에 페인트를 다시 칠해야 합니다.  
롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있고 1, 2, 3, 4번 영역에 페인트칠을 하면 한 번에 1, 3번 영역을 모두 칠할 수 있습니다.

![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/fb5be7bd-e792-4317-9868-f11e7aaf6f03/img2.png)

따라서 최소 횟수인 1을 return 합니다.

입출력 예 #3  
예제 3번은 모든 구역에 페인트칠을 해야 합니다.  
롤러의 길이가 1미터이므로 한 번에 한 구역밖에 칠할 수 없습니다.  
구역이 4개이므로 각 구역을 한 번씩만 칠하는 4번이 최소 횟수가 됩니다.

![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dddf1413-d81a-4199-a8e3-f10f58c59fcc/img3.png)

따라서 4를 return 합니다.

## 분석

`section`배열의 위치를 의미하는 요소에 롤러로 페인트 칠을 해야합니다.  
롤러는 한번에 `m`만큼의 롤러를 칠할 수 있고, 한번 칠하기 시작하면 떼지 않고 쭉 칠해야합니다.  
이때 롤러로 페인트 칠하는 최소 횟수를 구하는 문제입니다.

`section`은 중복된 값 없이 요소가 1개 이상이며, 오름차순으로 정렬 되어있습니다.

`n`과 `m`은 1 이상입니다.

## 풀이

```cpp
#include <vector>

using namespace std;

int solution(int n, int m, vector<int> section) {
    int answer = 1;
    
    int rollerStart = section[0];
    
    for (int i = 1; i < section.size(); ++i)
    {   
        if (section[i] - rollerStart >= m)
        {
            rollerStart = section[i];
            ++answer;
        }
    }
    
    return answer;
}
```

`rollerStart`은 롤러로 칠하려는 페인트 칠의 시작하는 위치입니다.

`section`을 순회하면서, 롤러가 시작한 위치부터 현재 칠해야하는 위치까지 칠할 수 있는지 확인합니다.  
칠 할 수 없는 위치라면 롤러의 시작 위치를 변경하며, 롤러가 칠하는 횟수를 증가시킵니다.

만약 `section`의 크기와 `m`, `n`이 1일 경우 반복문은 실행되지 않고, 바로 `answer`의 값이 반환됩니다.

## 성능 요약

시간 복잡도는 `section`을 순회하므로, $O(n)$입니다.

공간 복잡도는 고정된 크기의 상수 공간을 사용하기 때문에 $O(1)$입니다.

테스트 1 〉 통과 (0.16ms, 4.8MB)  
테스트 2 〉 통과 (0.20ms, 5.57MB)  
테스트 3 〉 통과 (0.16ms, 4.76MB)  
테스트 4 〉 통과 (0.01ms, 4.19MB)  
테스트 5 〉 통과 (0.24ms, 4.73MB)  
테스트 6 〉 통과 (0.01ms, 4.16MB)  
테스트 7 〉 통과 (0.01ms, 4.14MB)  
테스트 8 〉 통과 (0.09ms, 4.41MB)  
테스트 9 〉 통과 (0.01ms, 3.58MB)  
테스트 10 〉 통과 (0.13ms, 4.43MB)  
테스트 11 〉 통과 (0.01ms, 4.11MB)  
테스트 12 〉 통과 (0.10ms, 4.51MB)  
테스트 13 〉 통과 (0.30ms, 5.83MB)  
테스트 14 〉 통과 (0.24ms, 5.04MB)  
테스트 15 〉 통과 (0.01ms, 4.21MB)  
테스트 16 〉 통과 (0.07ms, 4.22MB)  
테스트 17 〉 통과 (0.20ms, 4.78MB)  
테스트 18 〉 통과 (0.01ms, 4.2MB)  
테스트 19 〉 통과 (0.17ms, 4.74MB)  
테스트 20 〉 통과 (0.14ms, 4.53MB)  
테스트 21 〉 통과 (0.18ms, 4.68MB)  
테스트 22 〉 통과 (0.22ms, 4.85MB)  
테스트 23 〉 통과 (0.23ms, 4.99MB)  
테스트 24 〉 통과 (0.01ms, 3.67MB)  
테스트 25 〉 통과 (0.15ms, 4.73MB)  
테스트 26 〉 통과 (0.08ms, 4.4MB)  
테스트 27 〉 통과 (0.05ms, 4.24MB)  
테스트 28 〉 통과 (0.01ms, 4.21MB)  
테스트 29 〉 통과 (0.01ms, 4.14MB)  
테스트 30 〉 통과 (0.01ms, 4.14MB)  
테스트 31 〉 통과 (0.01ms, 4.13MB)  
테스트 32 〉 통과 (0.01ms, 4.2MB)  
테스트 33 〉 통과 (0.01ms, 3.67MB)  
테스트 34 〉 통과 (0.01ms, 4.21MB)  
테스트 35 〉 통과 (0.13ms, 4.62MB)  
테스트 36 〉 통과 (0.01ms, 4.13MB)  
테스트 37 〉 통과 (0.08ms, 4.29MB)  
테스트 38 〉 통과 (0.01ms, 4.21MB)  
테스트 39 〉 통과 (0.08ms, 4.51MB)  
테스트 40 〉 통과 (0.01ms, 4.13MB)  
테스트 41 〉 통과 (0.27ms, 5.68MB)  
테스트 42 〉 통과 (0.01ms, 4.14MB)  
테스트 43 〉 통과 (0.01ms, 4.2MB)  
테스트 44 〉 통과 (0.01ms, 4.2MB)  
테스트 45 〉 통과 (0.22ms, 5.04MB)  
테스트 46 〉 통과 (0.04ms, 3.8MB)  
테스트 47 〉 통과 (0.23ms, 5.23MB)  
테스트 48 〉 통과 (0.10ms, 4.27MB)  
테스트 49 〉 통과 (0.12ms, 4.59MB)  
테스트 50 〉 통과 (0.16ms, 4.99MB)  

## 문제 링크

[덧칠하기](https://school.programmers.co.kr/learn/courses/30/lessons/161989){: target="_blank"}