---
layout: single

title: "[C++] 연산자와 연산자 우선순위"

categories:
    - Cpp
tag: [Cpp]

date: 2024-04-25
last_modified_at: 2024-04-26
---

# 연산자와 우선순위

## 연산자

연산자(Operator)란 프로그램에서 특정 작업을 수행하는 데 사용되는 기호 또는 키워드를 말합니다.

피연산자(operand) 데이터에 대해 여러가지 작업을 수행할 수 있습니다.  
연산자는 각각 특정한 연산을 수행하며 그 결과를 반환합니다.

### 산술 연산자

산술 연산자(Arithmetic Operator)란 수학적 계산에 사용되는 연산자들입니다.  
덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산이 필요할 때 사용합니다.

|연산자|설명|
|---|---|
|+|왼쪽 항에 오른쪽 항의 값을 더한다.|
|-|왼쪽 항에 오른쪽 항의 값을 뺀다.|
|*|왼쪽 항에 오른쪽 항의 값을 곱한다.|
|/|왼쪽 항을 오른쪽 항의 값으로 나눈다.|
|%|왼쪽 항을 오른쪽 항의 값으로 나눈 나머지|

이항 연산자로 피연산자가 2개입니다.  
피연산자가 float이나 double일 때 소수점까지 연산됩니다.

연산자 오버로딩을 통해 다른 클래스에 대해 다른 의미의 연산자를 위한 연산자를 정의할 수 있습니다.

```
int a = 5;
int b = 2;

a + b;  // 7
a - b;  // 3
a * b;  // 10
a / b;  // 2
a % b;  // 1
```

### 대입 연산자

대입 연산자(Assignment Operator)는 변수에 값을 대입할 때 사용합니다.

대입 연산자는 위의 산술 연산자와 결합한 복합 대입 연산자가 있습니다.
할당 연산자, 복합 할당 연산자로도 불립니다.

이항 연산자로 피연산자가 2개입니다.  
산술 연산자와 다르게 오른쪽 항에서 왼쪽 항으로 대입됩니다.

|연산자|설명|
|---|---|
|=|왼쪽 항에 오른쪽 항을 대입한다.|
|+=|왼쪽 항에 오른쪽 항을 더한 후 그 값을 왼쪽 항에 대입한다.|
|-=|왼쪽 항에 오른쪽 항을 뺀 후 그 값을 왼쪽 항에 대입한다.|
|*=|왼쪽 항에 오른쪽 항을 곱한 후 그 값을 왼쪽 항에 대입한다.|
|/=|왼쪽 항에 오른쪽 항을 나눈 후 그 값을 왼쪽 항에 대입한다.|
|%=|왼쪽 항에 오른쪽 항을 나눈 후 그 값의 나머지를 왼쪽 항에 대입한다.|

```
int a = 5;
int b = 5;
int c = 5;

a = a + 3;  // 8
b += 5;     // 13
c =+ 5;     // 5
```

=+ 연산은 숫자 5를 대입하는 연산이 됐습니다.  
이는 연산자의 순서가 다르기 때문인데, 이처럼 복합 대입 연산자는 순서가 매우 중요합니다.

### 증감 연산자

증감 연산자(increment and decrement operator)는 피연산자를 1씩 증가시키거나 감소시키는 연산자입니다.

|연산자|설명|
|---|---|
|++x|피연산자의 값을 1 증가시킨 후에 해당 연산을 진행한다.|
|x++|해당 연산을 진행한 후에 피연산자의 값을 1 증가시킨다.|
|--x|피연산자의 값을 1 감소시킨 후에 해당 연산을 진행한다.|
|x--|먼저 해당 연산을 진행한 후에 피연산자의 값을 1 감소시킨다.|

연산자가 변수 앞에 있는 경우를 "전위 증감"연산자라고 합니다.  
연산자가 변수 뒤에 있는 경우를 "후위 증감"연산자라고 합니다.  
전위, 후위의 의미는 다른 연산자와 함께 사용될 때 다른 연산자보다 먼저 처리(전위 증감) 되는가 후에 처리(후위 증감) 되는가를 지정합니다.

```
int a = 5;
int b = 2;

++a;    // 5
a--;    // 4

++a + b;    // 8
a++ + b;    // 8

int c = ++a + b;    // 8
int d = a++ + b;    // 7
```

$\mathrm{a}^{++} + \mathrm{b}$는 반환된 값이 8입니다. 하지만 $\mathrm{int \ d} = \mathrm{a}^{++} + \mathrm{b}$는 반환된 값이 7입니다.  
그 이유는 산술 연산자가 수행된 후 대입 연산자가 실행되며, 후위 증감 연산자이기 때문에 대입 연산자가 끝난 후 7에 증감 연산자가 실행 됩니다.

### 비교 연산자

비교 연산자(Comparison Operator)는 피연산자 사이의 상대적인 크기를 판단해 불리언 값을 반환하는 연산자입니다.  
피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

|연산자|설명|
|---|---|
|==|왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1을 반환한다.|
|!=|왼쪽의 피연산자와 오른쪽의 피연산자가 다르면 1을 반환한다.|
|>|왼쪽의 피연산자와 오른쪽의 피연산자보다 크면 1을 반환한다.|
|>=|왼쪽의 피연산자와 오른쪽의 피연산자 보다 크거나 같으면 1을 반환한다.|
|<|왼쪽의 피연산자와 오른쪽의 피연산자 보다 작으면 1을 반환한다.|
|<=|왼쪽의 피연산자와 오른쪽의 피연산자 보다 작거나 같으면 1을 반환한다.|

왼쪽의 피연산자와 오른쪽의 피연산자를 비교해 어느 쪽이 더 큰지, 작은지 혹은 서로 같은지를 판단합니다.

```
int a = 5;
int b = 2;

a == b; // false
a != b; // true
a > b;  // true
a >= b; // true
a < b;  // false
a <= b; // false
```

### 논리 연산자

논리 연산자(Logical Operator)는 불리언 표현식의 결과를 결정하는 연산자입니다.

AND 연산자와 OR연산자는 두 개의 피연산자를 가지는 이항 연산자입니다.  
피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

NOT 연산자는 피연산자가 하나뿐인 단항 연산자입니다.  
피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.

|연산자|설명|
|---|---|
|&&|논리식이 모두 참인 경우 1을 반환한다.(AND연산)|
|\|\||논리식 중 하나라도 참인 경우 1을 반환한다.(OR연산)|
|!|논리식의 결과가 참이면 0을 거짓이면 1을 반환한다.(NOT)|

### 비트 연산자

비트 연산자(Bitwise Operator)는 비트(bit)에 대해 연산을 수행합니다.  
피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

|연산자|설명|
|---|---|
|&|두 항의 각 자릿수를 비교해, 비트가 모두 1이면 1을 반환한다.(비트 AND)|
|\||두 항의 각 자릿수를 비교해, 비트 중에서 하나라도 1이면 1을 반환한다.(비트 OR)|
|^|두 항의 각 자릿수를 비교해, 비트가 서로 다를 경우 1을 반환(비트 XOR)|
|~|항의 각 자릿수의 비트가 1일경우 0으로, 0일 경우 1로 반환(비트 NOT, 1의 보수)|
|<<|지정한 수만큼 비트를 왼쪽으로 이동(Left Shift)|
|>>|지정한 수만큼 비트를 오른쪽으로 이동(Right Shift)|


```
unsigned int a = 0b1010;
unsigned int b = 0b1001;

a & b;  // 0000 1000
a | b;  // 0000 1011
a ^ b;  // 0000 0011;
~a;     // 0000 0101;
a << 1  // 0001 0100;
b >> 1  // 0000 0100;
```

$ \mathrm{b} >> 1$의 경우 왼쪽으로 비트가 이동하면서 가장 왼쪽에 있던 비트가 범위를 넘어가 소실됐습니다.  
이렇게 이진수의 끝에서 벗어난 비트는 소실됩니다.

### 삼항 연산자

삼항 연산자(Ternary Operator)는 C/C++에서 유일하게 세 개의 피연산자를 가집니다.

다음과 같은 문법을 가집니다.
```
조건식? 반환값1 : 반환값2
```

조건식이 참이라면 반환값1을 거짓이라면 반환값2를 반환합니다.

```
int a = 5;
int b = 2;

(a < b) ? a : b;    // 2
```

### 쉼표 연산자

쉼표 연산자(Comma Operator)는 두 개의 표현식을 동시에 표현하도록 도와주는 연산자입니다.  
피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

```
int a = 5, int b = 2;
```

항상 왼쪽 피연산자가 실행되고, 모든 파생 작용이 완료된 후에 오른쪽 피연산자가 실행됩니다.

쉼표는 연산자가 아닌 다른 역할로도 사용되는데, 분리자(Seperator)로도 사용됩니다.  
분리자는 함수 인수 목록과 같은 일부 컨텍스트에서 구분 기호로 사용될 수 있습니다.

다음은 변수의 선언을 구분해주는 분리자로 사용된 예시입니다.
```
int a = 5, int b = 2;   // 쉼표 연산자
int c, d;               // 분리자
```

### 범위 지정 연산자

범위 지정 연산자(Scope Resolution Operator)는 다양한 범위에서 사용되는 식별자(identifier)를 식별하고 명확하게 구분하는 데 사용됩니다.  

식별자로는 변수, 함수, 열거체가 올 수 있습니다.

```
::식별자
클래스이름::식별자
네임스페이스::식별자
열거체::식별자
```

범위 지정 연산자를 변수의 이름 앞에 붙이면 해당 변수는 전역으로 사용하라는 의미로 쓰입니다.  
같은 이름의 변수로 전역변수와 지역변수가 선언 돼있을 경우 전역변수에 접근 할 수 있습니다.

클래스에 사용하면 클래스의 정적 멤버를 호출합니다.

네임 스페이스에 사용하면 네임스페이스의 변수나 함수들을 호출할 수 있습니다.

### 멤버 포인터 연산자

멤버 포인터 연산자(Pointer-to-Member Operator)는 피연산자에 대한 특정 클래스 멤버의 값을 반환합니다.  
피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

연산자는 다음과 같이 두 가지의 형태가 있습니다.
+ 왼쪽의 피연산자가 클래스 타입의 객체인 경우: .*
- 왼쪽의 피연산자가 클래스 객체에 대한 포인터인 경우: ->*

다음과 같은 문법을 가집니다.
```
클래스 타입의 객체.*멤버이름
클래스 객체에 대한 포인터->*멤버이름
```

멤버 포인터 연산자는 정적 멤버 변수를 가리킬 수 없으며, 레퍼런스 멤버도 가리킬 수 없습니다.

### sizeof 연산자

sizeof 연산자는 피연산자의 타입이 차지하는 메모리 크기를 바이트(byte) 단위로 반환합니다.  
피연산자는 변수와 상수 또는 타입 자체일 수 있습니다.

```
int a = 5;

sizeof(char);   // 1
sizeof(short);  // 2
sizeof(a);      // 4
```

### typeid 연산자

typeid 연산자는 런타임에 객체의 타입을 확인할 수 있습니다.  
자료형이나 변수, 식을 받아 const type_info& 형식의 객체를 반환합니다.

반환된 값은 복사생성자나 대입연산자 사용이 금지돼있습니다.

## 연산자 우선순위 

연산자 우선순위(Operator Precedence)는 다음과 같습니다.

<table>
    <tr>
        <th>연산순위</th>
        <th>연산자</th>
        <th>설명</th>
        <th>결합 방향</th>
    </tr>
    <tr>
        <th>1</th>
        <td><code>::</code></td>
        <td>범위 지정 (scope resolution)</td>
        <td rowspan="10">좌 → 우</td>
    </tr>
    <tr>
        <th rowspan="9">2</th>
        <td><code>.</code> 또는 <code>-></code></td>
        <td>멤버 액세스</td>
    </tr>
    <tr>
        <td><code>[]</code></td>
        <td>배열 첨자</td>
    </tr>
    <tr>
        <td><code>()</code></td>
        <td>함수 호출</td>
    </tr>
    <tr>
        <td><code>++</code> 또는 <code>--</code></td>
        <td>후위 증가와 감소</td>
    </tr>
    <tr>
        <td><code>typeid</code></td>
        <td>타입 이름</td>
    </tr>
    <tr>
        <td><code>const_cast</code></td>
        <td>상수 타입 변환</td>
    </tr>
    <tr>
        <td><code>dynamic_cast</code></td>
        <td>동적 타입 변환</td>
    </tr>
    <tr>
        <td><code>reinterpret_cast</code></td>
        <td>재해석 타입 변환</td>
    </tr>
    <tr>
        <td><code>static_cast</code></td>
        <td>정적 타입 변환</td>
    </tr>
    <tr>
        <td rowspan="9">3</td>
        <td><code>sizeof</code></td>
        <td>개체 또는 타입의 크기</td>
        <td rowspan="9">우 → 좌</td>
    </tr>
    <tr>
        <td><code>++</code> 또는 <code>--</code></td>
        <td>전위 증가와 감소</td>
    </tr>
    <tr>
        <td><code>!</code> 또는 <code>~</code></td>
        <td>논리 NOT, 비트 NOT</td>
    </tr>
    <tr>
        <td><code>-</code> 또는 <code>+</code></td>
        <td>음의 부호, 양의 부호</td>
    </tr>
    <tr>
        <td><code>&</code></td>
        <td>주소값</td>
    </tr>
    <tr>
        <td><code>*</code></td>
        <td>역참조</td>
    </tr>
    <tr>
        <td><code>new</code> 또는 <code>new[]</code></td>
        <td>동적 메모리 할당</td>
    </tr>
    <tr>
        <td><code>delete</code> 또는 <code>delete[]</code></td>
        <td>동적 메모리 해제</td>
    </tr>
    <tr>
        <td><code>(type)</code></td>
        <td>타입 캐스트</td>
    </tr>
    <tr>
        <td>4</td>
        <td><code>.*</code> 또는 <code>.-></code></td>
        <td>멤버 포인터</td>
        <td rowspan="5">좌 → 우</td>
    </tr>
    <tr>
        <td>5</td>
        <td><code>*</code> 또는 <code>/</code> 또는 <code>%</code></td>
        <td>곱셈, 나누기, 나머지</td>
    </tr>
    <tr>
        <td>6</td>
        <td><code>+</code> 또는 <code>-</code></td>
        <td>더하기, 빼기</td>
    </tr>
    <tr>
        <td>7</td>
        <td><code><<</code> 또는 <code>>></code></td>
        <td>비트 왼쪽 시프트와 오른쪽 시프트</td>
    </tr>
    <tr>
        <td rowspan="2">8</td>
        <td><code><</code> 또는 <code><=</code></td>
        <td>비교(관계)연산자 < 와 ≤</td>
    </tr>
    <tr>
        <td><code>></code> 또는 <code>>=</code></td>
        <td>비교(관계)연산자 > 와 ≥</td>
    </tr>
    <tr>
        <td>9</td>
        <td><code>==</code> 또는 <code>!=</code></td>
        <td>비교(관계)연산자 = 와 ≠</td>
    </tr>
    <tr>
        <td>10</td>
        <td><code>&</code></td>
        <td>비트 AND</td>
    </tr>
    <tr>
        <td>11</td>
        <td><code>^</code></td>
        <td>배타적 비트 OR</td>
    </tr>
    <tr>
        <td>12</td>
        <td><code>|</code></td>
        <td>포괄적 비트 OR </td>
    </tr>
    <tr>
        <td>13</td>
        <td><code>&&</code></td>
        <td>논리적 AND</td>
    </tr>
    <tr>
        <td>14</td>
        <td><code>||</code></td>
        <td>논리적 OR</td>
    </tr>
    <tr>
        <td rowspan="6">15</td>
        <td><code>?:</code></td>
        <td>삼항 연산자(조건 연산자)</td>
        <td rowspan="7">우 → 좌</td>
    </tr>
    <tr>
        <td><code>=</code></td>
        <td>직접 대입</td>
    </tr>
    <tr>
        <td><code>*=</code> 또는 <code>/=</code> 또는 <code>%=</code></td>
        <td>곱, 몫, 나머지 대입</td>
    </tr>
    <tr>
        <td><code>+=</code> 또는 <code>-=</code></td>
        <td>합과 차 대입</td>
    </tr>
    <tr>
        <td><code><<=</code> 또는 <code>>>=</code></td>
        <td>비트 왼쪽 쉬프트와 오른쪽 쉬프트 후 할당</td>
    </tr>
    <tr>
        <td><code>&=</code> 또는 <code>^=</code> 또는 <code>|=</code></td>
        <td>비트 AND, 배타적 비트 OR, 포괄적 비트 OR 대입</td>
    </tr>
    <tr>
        <td>16</td>
        <td><code>throw</code></td>
        <td>(예외를 위한)Throw 연산자</td>
    </tr>
    <tr>
        <td>17</td>
        <td><code>,</code></td>
        <td>쉼표</td>
        <td>좌 → 우</td>
    </tr>
</table>