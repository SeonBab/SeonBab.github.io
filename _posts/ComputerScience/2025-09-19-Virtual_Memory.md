---
layout: single

title: "[ComputerScience] 가상 메모리"

categories:
    - ComputerScience
    
tag: [컴퓨터 과학, ComputerScience]

date: 2025-09-19
last_modified_at: 2025-09-19

order : 1220
---

# 가상 메모리

가상 메모리(Virtual Memory)는 실제 물리 메모리(RAM)보다 큰 메모리 공간을 제공하기 위해 운영체제가 사용하는 메모리 관리 기법입니다.  
프로세스마다 독립적인 주소 공간을 제공하여, 메모리 보호와 효율적인 자원 활용이 가능하게 합니다.

가상 메모리는 하드웨어(MMU)와 운영체제가 협력하여 논리 주소를 물리 주소로 변환하는 방식으로 구현됩니다.  
또한, 보조기억장치(디스크)의 일부를 메모리처럼 활용하여 RAM보다 큰 메모리 공간을 제공할 수 있습니다.

## 스와핑

스와핑(Swapping)은 메인 메모리가 부족할 때 프로세스 전체를 보조기억장치로 내보냈다가, 필요할 때 다시 메인 메모리로 불러오는 기법입니다.

실행되지 않는 프로세스를 디스크로 이동시켜 RAM을 확보하며, 실행 필요시 다시 RAM으로 적재합니다.

다중 프로그래밍 환경에서 더 많은 프로세스를 동시에 유지할 수 있습니다.

디스크 I/O 속도가 느리기 때문에 성능 저하가 발생합니다.

스왑 아웃 되었던 프로세스가 다시 스왑 인 될 때 다른 물리 주소로 적재될 수 있습니다.

스왑 아웃(Swap-Out)은 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것입니다.  
스왑 인(Swap-In)은 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것입니다.

### 스왑 영역

스왑 영역(Swap Area, Swap Space)은 스와핑 동작이 일어나는 디스크 상의 전용 공간(물리적 공간)입니다.  
RAM이 부족할 때 혹은 사용하지 않는 프로세스나 데이터를 임시로 저장하는 역할을 합니다.

디스크의 특정 파티션이나 파일 형태로 존재합니다.

RAM보다 속도는 느리지만, 부족한 메모리를 보완할 수 있습니다.  
SSD 사용 시 HDD보다 빠르지만, SSD 수명에 영향을 줄 수 있습니다.

## 페이징

페이징(Paging)은 비연속 메모리 할당 방식 중 하나로, 프로세스를 일정한 크기의 페이지(Page) 단위로 나누어 메모리에 배치하는 기법입니다.  
여기서 페이지는 프로세스를 나누는 최소 단위를 의미합니다.

물리 주소 공간을 페이지와 동일한 크기로 프레임(Frame) 단위로 나누어 페이지를 해당 프레임에 할당합니다.

페이지 단위로 할당되므로, 연속된 공간이 없어도 프로세스를 적재할 수 있어 외부 단편화를 방지합니다.  
마지막 페이지는 프로세스 크기보다 클 수 있어 일부 공간이 낭비되는 내부 단편화가 발생할 수 있습니다.

내부 단편화(Internal Fragmentation)는 페이지 하나의 크기보다 작은 크기로 발생하게 되는 메모리 낭비를 의미합니다.  
예를 들어 페이지의 크기는 10KB일 때, 프로세스의 크기가 17KB인 경우 마지막 페이지는 3KB만큼이 남습니다.

CPU가 사용하는 논리 주소에서 물리 주소로의 변환이 필요하기 때문에 MMU가 사용됩니다.  
논리 주소는 페이지 번호(Page Number) + 페이지 변위(Offset)으로 구성되어 있습니다.  
페이지 변위는 접근하려는 주소가 페이지(프레임)의 시작 번지로부터 얼만큼 떨어져 있는지 나타내는 정보입니다.

페이지 단위로 스왑 아웃 및 스왑 인이 이루어지며, CPU는 페이지 테이블을 통해 페이지 위치를 확인합니다.

### 페이지 테이블

페이지 테이블(Page Table)은 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보입니다.

페이지 번호와 실제로 적재된 프레임 번호가 대응됩니다.  
그렇기 때문에 CPU는 페이지 테이블의 페이지 번호만으로 적재된 프레임을 찾을 수 있습니다.

페이지 테이블의 정보를 가진 행을 테이블 엔트리(PTE, Page Table Entry)라고 부릅니다.

대표적인 정보는 다음과 같습니다.

- 페이지 번호
- 프레임 번호
- 유효 비트(Valid Bit): 해당 페이지에 접근이 가능한지 여부를 알려주는 중요한 정보
    + 현재 페이지가 메모리에 적재되어 있다면 1, 아닌 경우 0입니다.
    + 유효 비트가 0인 페이지에 접근하려고 하면 페이지 폴트(Page Fault)라는 예외(Exception)가 발생합니다.
- 보호 비트(Protection Bit): 페이지 보호 기능을 위해 존재하는 비트
    + 읽기(Read, r), 쓰기(Write, w), 실행(eXecute, x)의 조합으로 페이지에 접근할 권한을 제한
- 참조 비트(Reference Bit): CPU가 해당 페이지에 접근한 적이 있는지의 여부를 나타내는 비트
- 수정 비트(Modified Bit): 해당 페이지에 데이터를 쓴 적이 있는지 여부를 알려주는 비트
    + 수정 비트가 1이면 변경된 적이 있으며, 0인 경우 변견된 적 없는 페이지를 나타냅니다.
    + 더티 비트(Dirty Bit)라고도 부릅니다.

페이지 폴트가 발생한 경우 다음과 같습니다.

1. 기존 작업 내역을 백업
2. 원하는 페이지를 메모리로 가져와 유효 비트를 1로 변경해주는 페이지 폴트 처리 루틴 실행
3. 메모리에 적재된 페이지를 실행

페이지 폴트는 크게 두 종류가 있습니다.

- 메이저 페이저 폴트(Major Page Fault): CPU가 원하는 페이지를 읽어 들이기 위해 보조기억장치의 입출력 작업이 필요한 페이지 폴트
    + CPU가 접근하려는 페이지가 물리 메모리에 없을 때 발생
    + 성능 상의 악영향이 크다.
- 마이너 페이지 폴트(Minor Page Fault): 보조기억장치의 입출력이 필요하지 않은 페이지 폴트
    + CPU가 요청한 페이지가 물리 메모리에는 존재하지만, 페이지 테이블 상에는 반영되지 않을 때 발생
    + 메이저 페이지 폴트에 비해 성능 상의 악영향이 적다.

### 계층적 페이징

계층적 페이징은 페이지 테이블을 여러 단계로 나누어 관리하는 방법으로, 특정 페이지 테이블이 다른 페이지 테이블들의 페이지를 가리키게하는 방법입니다.

페이지 테이블을 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없어 메모리 사용 효율이 증가합니다.

### 페이지 교체 알고리즘

요구 페이징(Demand Paging)은 메모리에 필요한 페이지만을 적재하는 기법입니다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트 1) CPU는 페이지가 적재된 프레임에 접근합니다.
3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트 0) 페이지 폴트가 발생합니다.
4. 페이지 폴트가 발생하면 해당 페이지를 메모리 적재하고, 유효 비트를 1로 설정합니다.
5. 다시 1번의 과정을 수행

순수 요구 페이징(Pure Demand Paging)은 아무런 페이지도 메모리에 적재하지 않은 채 무작정 프로세스를 실행하는 기법입니다.

페이지 교체 알고리즘(Page Replacement Algorithm)은 메모리에 적재된 페이지 중 보조기억장치로 내보낼 페이지를 선택하는 방법입니다.

페이지 교체 알고리즘은 대표적으로 3가지가 있습니다.

1. FIFO 페이지 교체(First-In First-Out) 알고리즘: 메모리에 가장 먼저 적재된 페이지부터 스왑 아웃하는 페이지 교체 알고리즘
2. 최적 페이지 교체(Optimal Page Replacement) 알고리즘: 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
    - 예측하기 어렵기 때문에 실제 구현이 어려운 이상적인 알고리즘
3. LRU 페이지 교체(Least Recently Used Page Replacement) 알고리즘: 가장 적게 사용한 페이지를 교체하는 알고리즘

## 세그멘테이션

세그멘테이션(Segmentation)은 논리적 단위(Segment)로 나누어 메모리에 배치하는 기법입니다.

코드, 데이터, 스택 등을 논리 단위로 관리합니다.

세그먼트의 크기가 일정하지 않기 때문에 외부 단편화 문제가 발생할 수 있습니다.